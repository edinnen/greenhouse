package exploitBlock

import (
	"net"
	"net/http"
	"os"
	"regexp"

	"github.com/dgrijalva/jwt-go"
	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
	"github.com/sirupsen/logrus"
)

type Banned struct {
	IP   string `sql:"ip"`
	Path string `sql:"path"`
}

var WHITELIST = []string{
	`/$`,
	`/.*\.js$`,
	`/.*\.css$`,
	`/.*\.png$`,
	`/.*\.chunk\.js$`,
	`/.*\.woff2$`,
	`/.*\.css\.map$`,
	`/.*\.js\.map$`,
	`/favicon\.ico$`,
	`/manifest\.json$`,
	`/service-worker\.js$`,
	`/static/.*`,
	`/index.html`,
	`/service-worker\.js\.map$`,
	`/video`,
	`/zone/.*`,
	`/login`,
	`/.*/GetState`,
}

var database *sqlx.DB
var jwtKey = []byte(os.Getenv("JWT_SECRET"))

// Create a struct that will be encoded to a JWT.
// We add jwt.StandardClaims as an embedded type, to provide fields like expiry time
type Claims struct {
	jwt.StandardClaims
}

func CheckJWT(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				logrus.Error("Recovered from panic in CheckJWT ", err)
			}
		}()

		// Get the JWT token cookie from the request
		cookie, err := r.Cookie("jwt")
		if err != nil {
			logrus.Error("Failed to get JWT cookie", err)
			http.Error(w, "No video for you", http.StatusUnauthorized)
			http.Redirect(w, r, "/", http.StatusTemporaryRedirect)
			return
		}

		// Check if the token is valid
		_, err = jwt.ParseWithClaims(cookie.Value, &Claims{}, func(token *jwt.Token) (interface{}, error) {
			return jwtKey, nil
		})
		if err != nil {
			logrus.Error("Failed to parse JWT", err)
			http.Error(w, "No video for you", http.StatusUnauthorized)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// Protect routes by banning IP addresses which access any non whitelisted routes
func Protect(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				logrus.Error("Recovered from panic in Protect", err)
			}
		}()

		ip := getIP(r)

		inShawCIDR := checkCIDR(ip, "70.64.0.0/12")
		if inShawCIDR {
			next.ServeHTTP(w, r)
			return
		}

		db, err := sqlx.Open("sqlite3", "/storage/control.db")
		if err != nil {
			logrus.Error("Failed to open SQL database", err)
			next.ServeHTTP(w, r)
			return
		}
		database = db
		defer db.Close()

		bannedUser := checkBanned(database, ip)

		if bannedUser != nil {
			logrus.WithFields(logrus.Fields{
				"Path": r.URL.Path,
				"ip":   bannedUser.IP,
			}).Info("Blocking request from banned IP")
			http.Error(w, "ðŸ–• You are banned ðŸ–•", http.StatusForbidden)
			return
		}

		if !whitelisted(r.URL.Path) {
			logrus.WithFields(logrus.Fields{
				"Path": r.URL.Path,
				"ip":   ip,
			}).Info("Banning ip")

			statement, _ := database.Prepare("INSERT INTO banned VALUES (?, ?)")
			statement.Exec(ip, r.URL.Path)

			http.Error(w, "ðŸ–• You are banned ðŸ–•", http.StatusForbidden)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// checkCIDR will check if the provided IP address is in the provided CIDR range
func checkCIDR(ip string, cidr string) bool {
	ipAddress := net.ParseIP(ip)
	_, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		logrus.Error("Failed to parse CIDR", err)
		return false
	}

	return ipNet.Contains(ipAddress)
}

// getIP gets a requests IP address by reading off the forwarded-for
// header (for proxies) and falls back to use the remote address.
func getIP(r *http.Request) string {
	forwarded := r.Header.Get("X-FORWARDED-FOR")
	if forwarded != "" {
		return forwarded
	}

	ipReg := regexp.MustCompile(`\d+\.\d+\.\d+\.\d+`)
	return ipReg.FindString(r.RemoteAddr)
}

// checkBanned will query our SQL database to see if the provided IP was banned in the past.
func checkBanned(database *sqlx.DB, ip string) *Banned {
	createTable, _ := database.Prepare("CREATE TABLE IF NOT EXISTS banned (ip TEXT PRIMARY KEY, path TEXT)")
	createTable.Exec()

	findUser, _ := database.Preparex("SELECT * FROM banned WHERE ip = ? LIMIT 1")

	rows, err := findUser.Queryx(ip)
	if err != nil {
		logrus.Error("Failed to query banned table", err)
		return nil
	}
	defer rows.Close()

	var banned Banned
	for rows.Next() {
		rows.StructScan(&banned)
		return &banned
	}

	return nil
}

// whitelisted will check if the provided string matches any regex in our whitelist
func whitelisted(str string) bool {
	for _, r := range WHITELIST {
		regex := regexp.MustCompile(r)
		if regex.Match([]byte(str)) {
			return true
		}
	}
	return false
}
